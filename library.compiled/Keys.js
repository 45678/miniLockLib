// Generated by CoffeeScript 1.7.1
(function() {
  var BLAKE2, EmailAddressPattern, NACL, calculateCurve25519KeyPair, scrypt, zxcvbn;

  BLAKE2 = require("./BLAKE2");

  NACL = require("./NACL");

  scrypt = require("./scrypt-async");

  zxcvbn = require("./zxcvbn");

  exports.makeKeyPair = function(secretPhrase, emailAddress, callback) {
    var decodedEmailAddress, decodedSecretPhrase, hashDigestOfDecodedSecretPhrase;
    switch (false) {
      case (callback != null ? callback.constructor : void 0) === Function:
        return "Can’t make a pair of keys without a callback function.";
      case secretPhrase !== void 0:
        return callback("Can’t make a pair of keys without a secret phrase.");
      case exports.secretPhraseIsAcceptable(secretPhrase) !== false:
        return callback("Can’t make a pair of keys because the secret phrase is unacceptable.");
      case emailAddress !== void 0:
        return callback("Can’t make a pair of keys without an email address.");
      case exports.emailAddressIsAcceptable(emailAddress) !== false:
        return callback("Can’t make a pair of keys because the email address is unacceptable.");
      case !(secretPhrase && emailAddress && callback):
        decodedSecretPhrase = NACL.util.decodeUTF8(secretPhrase);
        decodedEmailAddress = NACL.util.decodeUTF8(emailAddress);
        hashDigestOfDecodedSecretPhrase = (new BLAKE2({
          length: 32
        })).update(decodedSecretPhrase).digest();
        return calculateCurve25519KeyPair(hashDigestOfDecodedSecretPhrase, decodedEmailAddress, function(keys) {
          return callback(void 0, keys);
        });
    }
  };

  calculateCurve25519KeyPair = function(secret, salt, callback) {
    var dkLen, encoding, interruptStep, logN, r, whenKeysAreReady;
    whenKeysAreReady = function(encodedBytes) {
      var decodedBytes, keys;
      decodedBytes = NACL.util.decodeBase64(encodedBytes);
      keys = NACL.box.keyPair.fromSecretKey(decodedBytes);
      return callback(keys);
    };
    logN = 17;
    r = 8;
    dkLen = 32;
    interruptStep = 1000;
    encoding = "base64";
    return scrypt(secret, salt, logN, r, dkLen, interruptStep, whenKeysAreReady, encoding);
  };

  exports.secretPhraseIsAcceptable = function(secretPhrase) {
    return (secretPhrase != null ? secretPhrase.length : void 0) >= 32 && zxcvbn(secretPhrase).entropy >= 100;
  };

  exports.emailAddressIsAcceptable = function(emailAddress) {
    return EmailAddressPattern.test(emailAddress);
  };

  EmailAddressPattern = /[-0-9A-Z.+_]+@[-0-9A-Z.+_]+\.[A-Z]{2,20}/i;

}).call(this);
