(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var Alice, Bobby, read, tape, _ref;

  _ref = require("./_fixtures"), Alice = _ref.Alice, Bobby = _ref.Bobby, read = _ref.read, tape = _ref.tape;

  tape("A demo of miniLockLib.encrypt & miniLockLib.decrypt", function(test) {
    return test.end();
  });

  tape("Encrypt a file for Alice", function(test) {
    return read("basic.txt", function(blob) {
      return miniLockLib.encrypt({
        data: blob,
        name: "alice.txt",
        keys: Alice.keys,
        miniLockIDs: [Alice.miniLockID],
        callback: function(error, encrypted) {
          if (error != null) {
            return test.end(error);
          }
          test.ok(encrypted.name === "alice.txt.minilock");
          test.ok(encrypted.data.size === 962);
          test.ok(encrypted.data.type === "application/minilock");
          test.ok(encrypted.senderID === Alice.miniLockID);
          return test.end();
        }
      });
    });
  });

  tape("Alice can decrypt file that was encrypted for her", function(test) {
    return read("alice.txt.minilock", function(blob) {
      return miniLockLib.decrypt({
        data: blob,
        keys: Alice.keys,
        callback: function(error, decrypted) {
          if (error) {
            return test.end(error);
          }
          test.ok(decrypted.data.size === 20);
          test.ok(decrypted.name === "alice.txt");
          test.ok(decrypted.senderID === Alice.miniLockID);
          test.ok(decrypted.recipientID === Alice.miniLockID);
          return test.end();
        }
      });
    });
  });

  tape("Bobby can’t decrypt file that was only encrypted for Alice", function(test) {
    return read("alice.txt.minilock", function(blob) {
      return miniLockLib.decrypt({
        data: blob,
        keys: Bobby.keys,
        callback: function(error, decrypted) {
          test.equal("File is not encrypted for this recipient", error);
          test.equal(void 0, decrypted);
          return test.end();
        }
      });
    });
  });

  tape("Encrypt a file for Alice & Bobby", function(test) {
    return read("basic.txt", function(blob) {
      return miniLockLib.encrypt({
        data: blob,
        name: "alice_and_bobby.txt",
        keys: Alice.keys,
        miniLockIDs: [Alice.miniLockID, Bobby.miniLockID],
        callback: function(error, encrypted) {
          if (error) {
            return test.end(error);
          }
          test.equal(encrypted.name, "alice_and_bobby.txt.minilock");
          test.equal(encrypted.data.size, 1508);
          test.equal(encrypted.data.type, "application/minilock");
          test.equal(encrypted.senderID, Alice.miniLockID);
          return test.end();
        }
      });
    });
  });

  tape("Alice can decrypt file that was encrypted for Alice & Bobby", function(test) {
    return read("alice_and_bobby.txt.minilock", function(blob) {
      return miniLockLib.decrypt({
        data: blob,
        keys: Alice.keys,
        callback: function(error, decrypted) {
          if (error) {
            return test.end(error);
          }
          test.ok(decrypted.data.size === 20);
          test.ok(decrypted.name === "alice_and_bobby.txt");
          test.ok(decrypted.senderID === Alice.miniLockID);
          test.ok(decrypted.recipientID === Alice.miniLockID);
          return test.end();
        }
      });
    });
  });

  tape("Bobby can decrypt file that was encrypted for Alice & Bobby", function(test) {
    return read("alice_and_bobby.txt.minilock", function(blob) {
      return miniLockLib.decrypt({
        data: blob,
        keys: Bobby.keys,
        callback: function(error, decrypted) {
          if (error) {
            return test.end(error);
          }
          test.ok(decrypted.data.size === 20);
          test.ok(decrypted.name === "alice_and_bobby.txt");
          test.ok(decrypted.senderID === Alice.miniLockID);
          test.ok(decrypted.recipientID === Bobby.miniLockID);
          return test.end();
        }
      });
    });
  });

}).call(this);

},{"./_fixtures":8}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var Alice, Bobby, tape, _ref;

  _ref = require("./_fixtures"), Alice = _ref.Alice, Bobby = _ref.Bobby, tape = _ref.tape;

  tape("Acceptability", function(test) {
    return test.end();
  });

  tape("Alice’s secret phrase is acceptable", function(test) {
    test.ok(miniLockLib.secretPhraseIsAcceptable(Alice.secretPhrase));
    return test.end();
  });

  tape("Bobby’s secret phrase is acceptable", function(test) {
    test.ok(miniLockLib.secretPhraseIsAcceptable(Bobby.secretPhrase));
    return test.end();
  });

  tape("Undefined secret phrase is unacceptable", function(test) {
    test.same(miniLockLib.secretPhraseIsAcceptable(void 0), false);
    return test.end();
  });

  tape("Empty secret phrase is unacceptable", function(test) {
    test.same(miniLockLib.secretPhraseIsAcceptable(""), false);
    return test.end();
  });

  tape("Blank secret phrase is unacceptable", function(test) {
    test.same(miniLockLib.secretPhraseIsAcceptable("  "), false);
    return test.end();
  });

  tape("Short secret phrase is unacceptable", function(test) {
    test.same(miniLockLib.secretPhraseIsAcceptable("My password is password"), false);
    return test.end();
  });

  tape("Alice’s email address is acceptable", function(test) {
    test.ok(miniLockLib.emailAddressIsAcceptable(Alice.emailAddress));
    return test.end();
  });

  tape("Bobby’s email address is acceptable", function(test) {
    test.ok(miniLockLib.emailAddressIsAcceptable(Bobby.emailAddress));
    return test.end();
  });

  tape("Empty email address is unacceptable", function(test) {
    test.same(miniLockLib.emailAddressIsAcceptable(""), false);
    return test.end();
  });

  tape("Blank email address is unacceptable", function(test) {
    test.same(miniLockLib.emailAddressIsAcceptable("  "), false);
    return test.end();
  });

  tape("Undefined email address is unacceptable", function(test) {
    test.same(miniLockLib.emailAddressIsAcceptable(void 0), false);
    return test.end();
  });

}).call(this);

},{"./_fixtures":8}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var Alice, Bobby, read, readFromNetwork, tape, _ref;

  _ref = require("./_fixtures"), Alice = _ref.Alice, Bobby = _ref.Bobby, read = _ref.read, readFromNetwork = _ref.readFromNetwork, tape = _ref.tape;

  tape("DecryptOperation", function(test) {
    return test.end();
  });

  tape("construct a blank miniLockLib.DecryptOperation", function(test) {
    test.ok(new miniLockLib.DecryptOperation);
    return test.end();
  });

  tape("define data, keys and callback when decrypt operation is constructed", function(test) {
    var blob, callback, operation;
    callback = function(error, decrypted) {};
    operation = new miniLockLib.DecryptOperation({
      data: (blob = new Blob),
      keys: Alice.keys,
      callback: callback
    });
    test.same(operation.data, blob);
    test.same(operation.keys, Alice.keys);
    test.same(operation.callback, callback);
    return test.end();
  });

  tape("or define the callback when start is called if you prefer", function(test) {
    var callbackSpecifiedOnStart, operation;
    callbackSpecifiedOnStart = function() {};
    operation = new miniLockLib.DecryptOperation({
      data: new Blob,
      keys: Alice.keys
    });
    operation.run = function() {
      test.same(operation.callback, callbackSpecifiedOnStart);
      return test.end();
    };
    return operation.start(callbackSpecifiedOnStart);
  });

  tape("can’t start a decrypt operation without data", function(test) {
    var operation;
    operation = new miniLockLib.DecryptOperation({
      keys: Alice.keys,
      callback: true
    });
    test.throws(operation.start, 'Can’t start miniLockLib.DecryptOperation without data.');
    return test.end();
  });

  tape("can’t start a decrypt operation without keys", function(test) {
    var operation;
    operation = new miniLockLib.DecryptOperation({
      data: true,
      callback: true
    });
    test.throws(operation.start, 'Can’t start miniLockLib.DecryptOperation without keys.');
    return test.end();
  });

  tape("can’t start a decrypt operation without a callback", function(test) {
    var operation;
    operation = new miniLockLib.DecryptOperation({
      data: true,
      keys: Alice.keys
    });
    test.throws(operation.start, 'Can’t start miniLockLib.DecryptOperation without a callback.');
    return test.end();
  });

  tape("read length of header from a file", function(test) {
    return read("alice.txt.minilock", function(blob) {
      var operation;
      operation = new miniLockLib.DecryptOperation({
        data: blob
      });
      return operation.readLengthOfHeader(function(error, lengthOfHeader) {
        test.equal(lengthOfHeader, 634);
        return test.end();
      });
    });
  });

  tape("read header of a file with one permit", function(test) {
    return read("alice.txt.minilock", function(blob) {
      var operation;
      operation = new miniLockLib.DecryptOperation({
        data: blob,
        keys: Alice.keys
      });
      return operation.readHeader(function(error, header) {
        var uniqueNonces;
        if (error) {
          return test.end(error);
        }
        test.ok(header.version === 1);
        test.ok(header.ephemeral.constructor === String);
        test.ok(header.ephemeral.length === 44);
        uniqueNonces = Object.keys(header.decryptInfo);
        test.ok(uniqueNonces.length === 1);
        test.ok(header.decryptInfo[uniqueNonces[0]].length === 508);
        return test.end();
      });
    });
  });

  tape("read header of a file with two permits", function(test) {
    return read("alice_and_bobby.txt.minilock", function(blob) {
      var operation;
      operation = new miniLockLib.DecryptOperation({
        data: blob
      });
      return operation.readHeader(function(error, header) {
        var uniqueNonces;
        if (error) {
          return test.end(error);
        }
        test.ok(header.version === 1);
        test.ok(header.ephemeral.constructor === String);
        test.ok(header.ephemeral.length === 44);
        uniqueNonces = Object.keys(header.decryptInfo);
        test.ok(uniqueNonces.length === 2);
        test.ok(header.decryptInfo[uniqueNonces[0]].length === 508);
        test.ok(header.decryptInfo[uniqueNonces[1]].length === 508);
        return test.end();
      });
    });
  });

  tape("decrypt uniqueNonce and permit from a file encrypted with miniLockLib", function(test) {
    return read("alice.txt.minilock", function(blob) {
      var operation;
      operation = new miniLockLib.DecryptOperation({
        data: blob,
        keys: Alice.keys
      });
      return operation.decryptUniqueNonceAndPermit(function(error, uniqueNonce, permit, lengthOfHeader) {
        if (error != null) {
          return test.end(error);
        }
        test.ok(uniqueNonce);
        test.ok(uniqueNonce.constructor === Uint8Array);
        test.ok(uniqueNonce.length === 24);
        test.ok(permit.senderID === Alice.miniLockID);
        test.ok(permit.recipientID === Alice.miniLockID);
        test.ok(permit.fileInfo.fileHash != null);
        test.ok(permit.fileInfo.fileKey.constructor === Uint8Array);
        test.ok(permit.fileInfo.fileKey.length === 32);
        test.ok(permit.fileInfo.fileNonce.constructor === Uint8Array);
        test.ok(permit.fileInfo.fileNonce.length === 16);
        test.ok(lengthOfHeader === 634);
        return test.end();
      });
    });
  });

  tape("decrypt file name", function(test) {
    return read("alice.txt.minilock", function(blob) {
      var operation;
      operation = new miniLockLib.DecryptOperation({
        data: blob,
        keys: Alice.keys
      });
      return operation.decryptName(function(error, nameWasDecrypted, positionOfLastNameByte) {
        test.ok(nameWasDecrypted === true);
        test.ok(operation.name === "alice.txt");
        test.ok(positionOfLastNameByte === 922);
        return test.end(error);
      });
    });
  });

}).call(this);

},{"./_fixtures":8}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var Alice, Bobby, read, readFromNetwork, tape, _ref;

  _ref = require("./_fixtures"), Alice = _ref.Alice, Bobby = _ref.Bobby, read = _ref.read, readFromNetwork = _ref.readFromNetwork, tape = _ref.tape;

  tape("EncryptOperation", function(test) {
    return test.end();
  });

  tape("construct a blank encrypt operation", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation;
    test.ok(operation);
    return test.end();
  });

  tape("define data, keys, miniLockIDs and callback when you construct an ecrypt operation", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation({
      data: new Blob,
      keys: Alice.keys,
      miniLockIDs: [],
      callback: function() {}
    });
    test.ok(operation.data);
    test.ok(operation.keys);
    test.ok(operation.miniLockIDs);
    test.ok(operation.callback);
    return test.end();
  });

  tape("can’t start an encrypt operation without data", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation({
      keys: Alice.keys,
      miniLockIDs: [],
      callback: function() {}
    });
    test.throws(operation.start, 'Can’t start miniLockLib.EncryptOperation without data.');
    return test.end();
  });

  tape("can’t start an encrypt operation without keys", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation({
      data: new Blob,
      miniLockIDs: [],
      callback: function() {}
    });
    test.throws(operation.start, 'Can’t start miniLockLib.EncryptOperation without keys.');
    return test.end();
  });

  tape("can’t start an encrypt operation without miniLockIDs", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation({
      data: new Blob,
      keys: Alice.keys,
      callback: function() {}
    });
    test.throws(operation.start, 'Can’t start miniLockLib.EncryptOperation without miniLockIDs.');
    return test.end();
  });

  tape("empty array of ciphertext bytes is ready after operation is constructed", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation;
    test.ok(operation.ciphertextBytes.length === 0);
    return test.end();
  });

  tape("ephemeral key pair is ready after operation is constructed", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation;
    test.ok(operation.ephemeral.publicKey != null);
    test.ok(operation.ephemeral.secretKey != null);
    return test.end();
  });

  tape("file key is ready after operation is constructed", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation;
    test.ok(operation.fileKey.constructor === Uint8Array);
    test.ok(operation.fileKey.length === 32);
    return test.end();
  });

  tape("file nonce is ready after operation is constructed", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation;
    test.ok(operation.fileNonce.constructor === Uint8Array);
    test.ok(operation.fileNonce.length === 16);
    return test.end();
  });

  tape("hash for ciphertext bytes is ready after operation is constructed", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation;
    test.ok(operation.hash.constructor === BLAKE2s);
    test.ok(operation.hash.digestLength === 32);
    test.ok(operation.hash.isFinished === false);
    test.ok(operation.hash.update != null);
    test.ok(operation.hash.digest != null);
    return test.end();
  });

  tape("decoded name has a fixed length of 256 bytes", function(test) {
    var decodedName, operation;
    operation = new miniLockLib.EncryptOperation({
      name: "untitled.txt"
    });
    decodedName = operation.fixedLengthDecodedName();
    test.same(decodedName.length, 256);
    return test.end();
  });

  tape("encrypt name of a file", function(test) {
    var decryptedChunk, decryptedName, decryptor, operation;
    operation = new miniLockLib.EncryptOperation({
      name: "untitled.txt"
    });
    operation.encryptName();
    test.ok(operation.ciphertextBytes.length === 1);
    decryptor = nacl.stream.createDecryptor(operation.fileKey, operation.fileNonce, operation.chunkSize);
    decryptedChunk = decryptor.decryptChunk(operation.ciphertextBytes[0], false);
    test.ok(decryptedChunk != null);
    decryptedName = nacl.util.encodeUTF8(decryptedChunk);
    test.ok(decryptedName.length === 256);
    test.ok(decryptedName.indexOf("untitled.txt") === 0);
    return test.end();
  });

  tape("construct a permit to decrypt for a recipient", function(test) {
    var operation, permit, uniqueNonce, _ref1;
    operation = new miniLockLib.EncryptOperation({
      keys: Alice.keys
    });
    _ref1 = operation.permit(Bobby.miniLockID), uniqueNonce = _ref1[0], permit = _ref1[1];
    test.ok(uniqueNonce.constructor === Uint8Array);
    test.ok(uniqueNonce.length === 24);
    test.ok(permit.senderID === Alice.miniLockID);
    test.ok(permit.recipientID === Bobby.miniLockID);
    test.ok(permit.fileInfo.constructor === String);
    test.ok(permit.fileInfo !== "");
    return test.end();
  });

  tape("recipient can decrypt the key, nonce and hash of the file encoded in their permit", function(test) {
    var decodedFileInfo, decryptedFileInfo, fileInfo, operation, permit, uniqueNonce, _ref1;
    operation = new miniLockLib.EncryptOperation({
      keys: Alice.keys
    });
    _ref1 = operation.permit(Bobby.miniLockID), uniqueNonce = _ref1[0], permit = _ref1[1];
    decodedFileInfo = nacl.util.decodeBase64(permit.fileInfo);
    decryptedFileInfo = nacl.box.open(decodedFileInfo, uniqueNonce, Alice.publicKey, Bobby.secretKey);
    test.ok(decryptedFileInfo);
    fileInfo = JSON.parse(nacl.util.encodeUTF8(decryptedFileInfo));
    test.ok(fileInfo.fileKey != null);
    test.ok(fileInfo.fileNonce != null);
    test.ok(fileInfo.fileHash === "aSF6MHmQgJThESHQQjVKfB9VtkgsoaUeGyUN/R7Q7vk=");
    return test.end();
  });

  tape("header specifies version 1 of the miniLock file format", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation({
      keys: Alice.keys,
      miniLockIDs: [Alice.miniLockID]
    });
    operation.constructHeader();
    test.ok(operation.header.version === 1);
    return test.end();
  });

  tape("header has a Base64 encoded 32-byte ephemeral key", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation({
      keys: Alice.keys,
      miniLockIDs: [Alice.miniLockID]
    });
    operation.constructHeader();
    test.ok(nacl.util.decodeBase64(operation.header.ephemeral).length === 32);
    return test.end();
  });

  tape("header for one recipient has one permit", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation({
      keys: Alice.keys,
      miniLockIDs: [Alice.miniLockID]
    });
    operation.constructHeader();
    test.ok(Object.keys(operation.header.decryptInfo).length === 1);
    return test.end();
  });

  tape("header for two recipients has two permits", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation({
      keys: Alice.keys,
      miniLockIDs: [Alice.miniLockID, Bobby.miniLockID]
    });
    operation.constructHeader();
    test.ok(Object.keys(operation.header.decryptInfo).length === 2);
    return test.end();
  });

}).call(this);

},{"./_fixtures":8}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var Alice, Bobby, read, readFromNetwork, tape, _ref;

  _ref = require("./_fixtures"), Alice = _ref.Alice, Bobby = _ref.Bobby, read = _ref.read, readFromNetwork = _ref.readFromNetwork, tape = _ref.tape;

  tape("Identification", function(test) {
    return test.end();
  });

  tape("Alice’s ID is acceptable", function(test) {
    test.same(miniLockLib.ID.isAcceptable(Alice.miniLockID), true);
    return test.end();
  });

  tape("Bobby’s ID is acceptable", function(test) {
    test.same(miniLockLib.ID.isAcceptable(Alice.miniLockID), true);
    return test.end();
  });

  tape("Undefined ID is unacceptable", function(test) {
    test.same(miniLockLib.ID.isAcceptable(undefined), false);
    return test.end();
  });

  tape("Blank ID is unacceptable", function(test) {
    test.same(miniLockLib.ID.isAcceptable(""), false);
    test.same(miniLockLib.ID.isAcceptable(" "), false);
    test.same(miniLockLib.ID.isAcceptable("  "), false);
    return test.end();
  });

  tape("Truncated ID is unacceptable", function(test) {
    test.same(miniLockLib.ID.isAcceptable(Alice.miniLockID.slice(0, -1)), false);
    test.same(miniLockLib.ID.isAcceptable(Alice.miniLockID.slice(1)), false);
    return test.end();
  });

  tape("ID with extra characters is unacceptable", function(test) {
    test.same(miniLockLib.ID.isAcceptable(Alice.miniLockID + "A"), false);
    test.same(miniLockLib.ID.isAcceptable("A" + Alice.miniLockID), false);
    return test.end();
  });

  tape("Decode public key from Alice’s ID", function(test) {
    var publicKey;
    publicKey = miniLockLib.ID.decode(Alice.miniLockID);
    test.same(publicKey, Alice.publicKey);
    return test.end();
  });

  tape("Decode public key from Bobby’s ID", function(test) {
    var publicKey;
    publicKey = miniLockLib.ID.decode(Bobby.miniLockID);
    test.same(publicKey, Bobby.publicKey);
    return test.end();
  });

  tape("Make ID for Alice’s public key", function(test) {
    var miniLockID;
    miniLockID = miniLockLib.ID.encode(Alice.publicKey);
    test.same(miniLockID, Alice.miniLockID);
    return test.end();
  });

  tape("Make ID for Bobby’s public key", function(test) {
    var miniLockID;
    miniLockID = miniLockLib.ID.encode(Alice.publicKey);
    test.same(miniLockID, Alice.miniLockID);
    return test.end();
  });

  tape("Can’t make ID for undefined key", function(test) {
    var miniLockID;
    miniLockID = miniLockLib.ID.encode(undefined);
    test.same(miniLockID, undefined);
    return test.end();
  });

  tape("Can’t make ID for key that is too short", function(test) {
    var miniLockID;
    miniLockID = miniLockLib.ID.encode(new Uint8Array(16));
    test.same(miniLockID, undefined);
    return test.end();
  });

  tape("Can’t make ID for key that is too long", function(test) {
    var miniLockID;
    miniLockID = miniLockLib.ID.encode(new Uint8Array(64));
    test.same(miniLockID, undefined);
    return test.end();
  });

}).call(this);

},{"./_fixtures":8}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var Alice, Bobby, read, readFromNetwork, tape, _ref;

  _ref = require("./_fixtures"), Alice = _ref.Alice, Bobby = _ref.Bobby, read = _ref.read, readFromNetwork = _ref.readFromNetwork, tape = _ref.tape;

  tape("Key Pair", function(test) {
    return test.end();
  });

  tape("Compute Alice’s keys from her secret phrase and email address", function(test) {
    return miniLockLib.getKeyPair(Alice.secretPhrase, Alice.emailAddress, function(keys) {
      test.ok(Object.keys(keys).length === 2);
      test.same(keys.publicKey, Alice.publicKey);
      test.same(keys.secretKey, Alice.secretKey);
      return test.end();
    });
  });

  tape("Compute Bobby’s keys from his secret phrase and email address", function(test) {
    return miniLockLib.getKeyPair(Bobby.secretPhrase, Bobby.emailAddress, function(keys) {
      test.ok(Object.keys(keys).length === 2);
      test.same(keys.publicKey, Bobby.publicKey);
      test.same(keys.secretKey, Bobby.secretKey);
      return test.end();
    });
  });

}).call(this);

},{"./_fixtures":8}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var Alice, Bobby, read, readFromNetwork, tape, _ref;

  _ref = require("./_fixtures"), Alice = _ref.Alice, Bobby = _ref.Bobby, read = _ref.read, readFromNetwork = _ref.readFromNetwork, tape = _ref.tape;

  tape("Slow Operations", function(test) {
    return test.end();
  });

  tape("decrypt 1MB file for Alice", function(test) {
    return readFromNetwork("1MB.tiff.for.Alice.minilock", function(blob) {
      var operation;
      operation = new miniLockLib.DecryptOperation({
        data: blob,
        keys: Alice.keys
      });
      return operation.start(function(error, decrypted) {
        if (error != null) {
          return test.end(error);
        }
        test.ok(decrypted.data.size === 1048826);
        test.ok(decrypted.name === "1MB.tiff");
        test.ok(decrypted.senderID === Alice.miniLockID);
        test.ok(decrypted.recipientID === Alice.miniLockID);
        test.end();
        return console.info("decrypted", decrypted.name, decrypted);
      });
    });
  });

  tape("decrypt 4MB file for Alice", function(test) {
    return readFromNetwork("4MB.tiff.for.Alice.minilock", function(blob) {
      var operation;
      operation = new miniLockLib.DecryptOperation({
        data: blob,
        keys: Alice.keys
      });
      return operation.start(function(error, decrypted) {
        if (error != null) {
          return test.end(error);
        }
        test.ok(decrypted.data.size === 4194746);
        test.ok(decrypted.name === "4MB.tiff");
        test.ok(decrypted.senderID === Alice.miniLockID);
        test.ok(decrypted.recipientID === Alice.miniLockID);
        test.end();
        return console.info("decrypted", decrypted.name, decrypted);
      });
    });
  });

  tape("encrypt 1MB file for Alice", function(test) {
    return readFromNetwork("1MB.tiff", function(blob) {
      var operation;
      operation = new miniLockLib.EncryptOperation({
        data: blob,
        name: "alice.1MB.tiff",
        keys: Alice.keys,
        miniLockIDs: [Alice.miniLockID]
      });
      return operation.start(function(error, encrypted) {
        if (error != null) {
          return test.end(error);
        }
        test.ok(encrypted.data.size === 1049788);
        test.ok(encrypted.name === "alice.1MB.tiff.minilock");
        test.ok(encrypted.senderID === Alice.miniLockID);
        test.end();
        return console.info("encrypted", encrypted.name, encrypted);
      });
    });
  });

  tape("encrypt 4MB file for Alice", function(test) {
    return readFromNetwork("4MB.tiff", function(blob) {
      var operation;
      operation = new miniLockLib.EncryptOperation({
        data: blob,
        name: "alice.4MB.tiff",
        keys: Alice.keys,
        miniLockIDs: [Alice.miniLockID]
      });
      return operation.start(function(error, encrypted) {
        if (error != null) {
          return test.end(error);
        }
        test.ok(encrypted.data.size === 4195768);
        test.ok(encrypted.name === "alice.4MB.tiff.minilock");
        test.ok(encrypted.senderID === Alice.miniLockID);
        test.end();
        return console.info("encrypted", encrypted.name, encrypted);
      });
    });
  });

}).call(this);

},{"./_fixtures":8}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var Alice, Bobby, assertionTemplate, body, delay, failedTests, failureTemplate, findElementForTest, fixBrokenThrowsOperatorData, idOfCurrentlyRunningTest, insertFailure, insertTestAssertion, insertTestElement, numberOfFailedTests, numberOfTests, read, readFromNetwork, renderBodyElement, renderTestElementEnded, renderTestElementUpdate, testTemplate, untouched,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Alice = exports.Alice = {};

  Alice.secretPhrase = "lions and tigers are not the only ones i am worried about";

  Alice.emailAddress = "alice@example.com";

  Alice.miniLockID = "CeF5fM7SEdphjktdUbAXaMGm13m6mTZtbprtghvsMRYgw";

  Alice.publicKey = Base58.decode("3dz7VdGxZYTDQHHgXij2wgV3GRBu4GzJ8SLuwmAVB4kR");

  Alice.secretKey = Base58.decode("DsMtZntcp7riiWy9ng1xZ29tMPZQ9ioHNzk2i1UyChkF");

  Alice.keys = {
    publicKey: Alice.publicKey,
    secretKey: Alice.secretKey
  };

  Bobby = exports.Bobby = {};

  Bobby.secretPhrase = "No I also got a quesadilla, it’s from the value menu";

  Bobby.emailAddress = "bobby@example.com";

  Bobby.miniLockID = "2CtUp8U3iGykxaqyEDkGJjgZTsEtzzYQCd8NVmLspM4i2b";

  Bobby.publicKey = Base58.decode("GqNFkqGZv1dExFGTZLmhiqqbBUcoDarD9e1nwTFgj9zn");

  Bobby.secretKey = Base58.decode("A699ac6jesP643rkM71jAxs33wY9mk6VoYDQrG9B3Kw7");

  Bobby.keys = {
    publicKey: Bobby.publicKey,
    secretKey: Bobby.secretKey
  };

  read = exports.read = function(name, callback) {
    return read.files[name](function(error, processed) {
      if (error) {
        throw error;
      }
      return callback(processed.data);
    });
  };

  read.files = {
    "basic.txt": function(callback) {
      return callback(void 0, {
        data: new Blob(["This is only a test!"], {
          type: "text/plain"
        }),
        name: "basic.txt"
      });
    },
    "alice.txt.minilock": function(callback) {
      return miniLockLib.encrypt({
        data: new Blob(["This is only a test!"], {
          type: "text/plain"
        }),
        name: "alice.txt",
        keys: Alice.keys,
        miniLockIDs: [Alice.miniLockID],
        'callback': callback
      });
    },
    "alice_and_bobby.txt.minilock": function(callback) {
      return miniLockLib.encrypt({
        data: new Blob(["This is only a test!"], {
          type: "text/plain"
        }),
        name: "alice_and_bobby.txt",
        keys: Alice.keys,
        miniLockIDs: [Alice.miniLockID, Bobby.miniLockID],
        'callback': callback
      });
    }
  };

  readFromNetwork = exports.readFromNetwork = function(name, callback) {
    var request;
    request = new XMLHttpRequest;
    request.open("GET", "/tests/_fixtures/" + name, true);
    request.responseType = "blob";
    request.onreadystatechange = function(event) {
      if (request.readyState === 4) {
        return callback(request.response);
      }
    };
    return request.send();
  };

  exports.tape = window.tape.createHarness();

  testTemplate = document.getElementById("test_template");

  failureTemplate = document.getElementById("failure_template");

  assertionTemplate = document.getElementById("assertion_template");

  numberOfTests = document.getElementById("number_of_tests");

  numberOfFailedTests = document.getElementById("number_of_failed_tests");

  body = document.body;

  idOfCurrentlyRunningTest = void 0;

  untouched = true;

  failedTests = [];

  window.onmousewheel = function() {
    window.onmousewheel = void 0;
    return untouched = false;
  };

  delay = function(amount, callback) {
    return setTimeout(callback, amount);
  };

  exports.tape.createStream({
    objectMode: true
  }).on("data", function(data) {
    var element;
    switch (false) {
      case data.type !== "test":
        idOfCurrentlyRunningTest = data.id;
        insertTestElement(data);
        return renderBodyElement(data);
      case data.operator == null:
        fixBrokenThrowsOperatorData(data);
        if (data.ok === false) {
          if (__indexOf.call(failedTests, idOfCurrentlyRunningTest) < 0) {
            failedTests.push(idOfCurrentlyRunningTest);
          }
        }
        element = findElementForTest(idOfCurrentlyRunningTest);
        renderTestElementUpdate(element, data);
        insertTestAssertion(element, data);
        if (!data.ok) {
          return insertFailure(element, data);
        }
        break;
      case data.type !== "end":
        idOfCurrentlyRunningTest = void 0;
        renderTestElementEnded(findElementForTest(data.test), data);
        if (failedTests.length !== 0) {
          numberOfFailedTests.innerText = failedTests.length;
        }
        numberOfTests.innerText = data.test;
        return renderBodyElement(data);
      default:
        return console.info("Unhandled", data);
    }
  });

  renderBodyElement = function(data) {
    body.className = body.className.replace("undefined", "");
    body.className = (function() {
      switch (false) {
        case data.type !== "test":
          return body.className.replace("stopped", "running");
        case data.type !== "end":
          return body.className.replace("running", "stopped");
        default:
          return body.className;
      }
    })();
    if (failedTests.length === 1 && body.className.indexOf("fail") === -1) {
      return body.className += " failures";
    }
  };

  insertTestElement = function(data) {
    var element;
    element = testTemplate.cloneNode(true);
    element.id = "test_" + data.id;
    element.querySelector(".name").innerText = data.name;
    element.className += " started";
    document.body.appendChild(element);
    if (untouched) {
      element.scrollIntoView();
    }
    element.startedAt = Date.now();
    return element.querySelector("div.id").innerText = (data.id / 1000).toFixed(3).replace("0.", "#");
  };

  renderTestElementUpdate = function(element, data) {
    var className;
    className = data.ok ? "ok" : "failed";
    return element.className = element.className.replace(className, "").trim() + " " + className;
  };

  renderTestElementEnded = function(element, data) {
    element.className = element.className.replace("started", "ended");
    return element.querySelector("div.duration").innerText = "" + (((Date.now() - element.startedAt) / 1000).toFixed(2)) + "s";
  };

  insertTestAssertion = function(element, data) {
    var assertionEl;
    assertionEl = assertionTemplate.cloneNode(true);
    assertionEl.id = "test_" + idOfCurrentlyRunningTest + "_assertion_" + data.id;
    element.className = element.className.replace('empty', '').trim();
    return element.querySelector('.assertions').appendChild(assertionEl);
  };

  insertFailure = function(element, data) {
    var failureEl;
    failureEl = failureTemplate.cloneNode("true");
    failureEl.id = "";
    if (typeof data.expected === "function") {
      failureEl.querySelector("pre.expected").innerHTML += data.expected;
    } else {
      failureEl.querySelector("pre.expected").innerHTML += JSON.stringify(data.expected, void 0, "  ");
    }
    if (typeof data.actual === "function") {
      failureEl.querySelector("pre.received").innerHTML += data.actual;
    } else {
      failureEl.querySelector("pre.received").innerHTML += JSON.stringify(data.actual, void 0, "  ");
    }
    if (data.error != null) {
      failureEl.querySelector("pre.error_stack").innerText = data.error.stack;
    }
    element.appendChild(failureEl);
    if (failedTests.length === 1) {
      if (untouched === true) {
        return delay(1, function() {
          untouched = false;
          return element.scrollIntoView(true);
        });
      }
    }
  };

  fixBrokenThrowsOperatorData = function(data) {
    if ((data.operator === "throws") && (data.name !== data.actual)) {
      data.ok = false;
      data.expected = data.name;
      data.name = void 0;
      return data.fixedForThrowsOperator = true;
    }
  };

  findElementForTest = function(id) {
    return document.getElementById("test_" + id);
  };

}).call(this);

},{}]},{},[1,2,3,4,5,6,7,8]);
