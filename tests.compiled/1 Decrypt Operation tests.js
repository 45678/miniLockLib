// Generated by CoffeeScript 1.7.1
(function() {
  var Alice, Bobby, read, readFromNetwork, tape, _ref;

  tape = require("./tape_test_harness");

  _ref = require("./fixtures"), Alice = _ref.Alice, Bobby = _ref.Bobby, read = _ref.read, readFromNetwork = _ref.readFromNetwork;

  tape("DecryptOperation", function(test) {
    return test.end();
  });

  tape("construct a blank miniLockLib.DecryptOperation", function(test) {
    test.ok(new miniLockLib.DecryptOperation);
    return test.end();
  });

  tape("define data, keys and callback when decrypt operation is constructed", function(test) {
    var blob, callback, operation;
    callback = function(error, decrypted) {};
    operation = new miniLockLib.DecryptOperation({
      data: (blob = new Blob),
      keys: Alice.keys,
      callback: callback
    });
    test.same(operation.data, blob);
    test.same(operation.keys, Alice.keys);
    test.same(operation.callback, callback);
    return test.end();
  });

  tape("or define the callback when start is called if you prefer", function(test) {
    var callbackSpecifiedOnStart, operation;
    callbackSpecifiedOnStart = function() {};
    operation = new miniLockLib.DecryptOperation({
      data: new Blob,
      keys: Alice.keys
    });
    operation.run = function() {
      test.same(operation.callback, callbackSpecifiedOnStart);
      return test.end();
    };
    return operation.start(callbackSpecifiedOnStart);
  });

  tape("can’t start a decrypt operation without data", function(test) {
    var operation;
    operation = new miniLockLib.DecryptOperation({
      keys: Alice.keys,
      callback: true
    });
    test.throws(operation.start, 'Can’t start miniLockLib.DecryptOperation without data.');
    return test.end();
  });

  tape("can’t start a decrypt operation without keys", function(test) {
    var operation;
    operation = new miniLockLib.DecryptOperation({
      data: true,
      callback: true
    });
    test.throws(operation.start, 'Can’t start miniLockLib.DecryptOperation without keys.');
    return test.end();
  });

  tape("can’t start a decrypt operation without a callback", function(test) {
    var operation;
    operation = new miniLockLib.DecryptOperation({
      data: true,
      keys: Alice.keys
    });
    test.throws(operation.start, 'Can’t start miniLockLib.DecryptOperation without a callback.');
    return test.end();
  });

  tape("read length of header from a file", function(test) {
    return read("alice.txt.minilock", function(blob) {
      var operation;
      operation = new miniLockLib.DecryptOperation({
        data: blob
      });
      return operation.readLengthOfHeader(function(error, lengthOfHeader) {
        test.equal(lengthOfHeader, 634);
        return test.end();
      });
    });
  });

  tape("read header of a file with one permit", function(test) {
    return read("alice.txt.minilock", function(blob) {
      var operation;
      operation = new miniLockLib.DecryptOperation({
        data: blob,
        keys: Alice.keys
      });
      return operation.readHeader(function(error, header) {
        var uniqueNonces;
        if (error) {
          return test.end(error);
        }
        test.ok(header.version === 1);
        test.ok(header.ephemeral.constructor === String);
        test.ok(header.ephemeral.length === 44);
        uniqueNonces = Object.keys(header.decryptInfo);
        test.ok(uniqueNonces.length === 1);
        test.ok(header.decryptInfo[uniqueNonces[0]].length === 508);
        return test.end();
      });
    });
  });

  tape("read header of a file with two permits", function(test) {
    return read("alice_and_bobby.txt.minilock", function(blob) {
      var operation;
      operation = new miniLockLib.DecryptOperation({
        data: blob
      });
      return operation.readHeader(function(error, header) {
        var uniqueNonces;
        if (error) {
          return test.end(error);
        }
        test.ok(header.version === 1);
        test.ok(header.ephemeral.constructor === String);
        test.ok(header.ephemeral.length === 44);
        uniqueNonces = Object.keys(header.decryptInfo);
        test.ok(uniqueNonces.length === 2);
        test.ok(header.decryptInfo[uniqueNonces[0]].length === 508);
        test.ok(header.decryptInfo[uniqueNonces[1]].length === 508);
        return test.end();
      });
    });
  });

  tape("decrypt uniqueNonce and permit from a file encrypted with miniLockLib", function(test) {
    return read("alice.txt.minilock", function(blob) {
      var operation;
      operation = new miniLockLib.DecryptOperation({
        data: blob,
        keys: Alice.keys
      });
      return operation.decryptUniqueNonceAndPermit(function(error, uniqueNonce, permit, lengthOfHeader) {
        if (error != null) {
          return test.end(error);
        }
        test.ok(uniqueNonce);
        test.ok(uniqueNonce.constructor === Uint8Array);
        test.ok(uniqueNonce.length === 24);
        test.ok(permit.senderID === Alice.miniLockID);
        test.ok(permit.recipientID === Alice.miniLockID);
        test.ok(permit.fileInfo.fileHash != null);
        test.ok(permit.fileInfo.fileKey.constructor === Uint8Array);
        test.ok(permit.fileInfo.fileKey.length === 32);
        test.ok(permit.fileInfo.fileNonce.constructor === Uint8Array);
        test.ok(permit.fileInfo.fileNonce.length === 16);
        test.ok(lengthOfHeader === 634);
        return test.end();
      });
    });
  });

  tape("decrypt file name", function(test) {
    return read("alice.txt.minilock", function(blob) {
      var operation;
      operation = new miniLockLib.DecryptOperation({
        data: blob,
        keys: Alice.keys
      });
      return operation.decryptName(function(error, nameWasDecrypted, positionOfLastNameByte) {
        test.ok(nameWasDecrypted === true);
        test.ok(operation.name === "alice.txt");
        test.ok(positionOfLastNameByte === 922);
        return test.end(error);
      });
    });
  });

}).call(this);
