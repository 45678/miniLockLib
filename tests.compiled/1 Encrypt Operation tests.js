// Generated by CoffeeScript 1.7.1
(function() {
  var Alice, Bobby, read, readFromNetwork, tape, _ref;

  tape = require("./tape_test_harness");

  _ref = require("./fixtures"), Alice = _ref.Alice, Bobby = _ref.Bobby, read = _ref.read, readFromNetwork = _ref.readFromNetwork;

  tape("EncryptOperation", function(test) {
    return test.end();
  });

  tape("construct a blank encrypt operation", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation;
    test.ok(operation);
    return test.end();
  });

  tape("define data, keys, miniLockIDs and callback when you construct an ecrypt operation", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation({
      data: new Blob,
      keys: Alice.keys,
      miniLockIDs: [],
      callback: function() {}
    });
    test.ok(operation.data);
    test.ok(operation.keys);
    test.ok(operation.miniLockIDs);
    test.ok(operation.callback);
    return test.end();
  });

  tape("can’t start an encrypt operation without data", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation({
      keys: Alice.keys,
      miniLockIDs: [],
      callback: function() {}
    });
    test.throws(operation.start, 'Can’t start miniLockLib.EncryptOperation without data.');
    return test.end();
  });

  tape("can’t start an encrypt operation without keys", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation({
      data: new Blob,
      miniLockIDs: [],
      callback: function() {}
    });
    test.throws(operation.start, 'Can’t start miniLockLib.EncryptOperation without keys.');
    return test.end();
  });

  tape("can’t start an encrypt operation without miniLockIDs", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation({
      data: new Blob,
      keys: Alice.keys,
      callback: function() {}
    });
    test.throws(operation.start, 'Can’t start miniLockLib.EncryptOperation without miniLockIDs.');
    return test.end();
  });

  tape("empty array of ciphertext bytes is ready after operation is constructed", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation;
    test.ok(operation.ciphertextBytes.length === 0);
    return test.end();
  });

  tape("ephemeral key pair is ready after operation is constructed", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation;
    test.ok(operation.ephemeral.publicKey != null);
    test.ok(operation.ephemeral.secretKey != null);
    return test.end();
  });

  tape("file key is ready after operation is constructed", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation;
    test.ok(operation.fileKey.constructor === Uint8Array);
    test.ok(operation.fileKey.length === 32);
    return test.end();
  });

  tape("file nonce is ready after operation is constructed", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation;
    test.ok(operation.fileNonce.constructor === Uint8Array);
    test.ok(operation.fileNonce.length === 16);
    return test.end();
  });

  tape("hash for ciphertext bytes is ready after operation is constructed", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation;
    test.ok(operation.hash.digestLength === 32);
    test.ok(operation.hash.isFinished === false);
    test.ok(operation.hash.update != null);
    test.ok(operation.hash.digest != null);
    return test.end();
  });

  tape("decoded name has a fixed length of 256 bytes", function(test) {
    var decodedName, operation;
    operation = new miniLockLib.EncryptOperation({
      name: "untitled.txt"
    });
    decodedName = operation.fixedLengthDecodedName();
    test.same(decodedName.length, 256);
    return test.end();
  });

  tape("encrypt name of a file", function(test) {
    var decryptor, operation;
    operation = new miniLockLib.EncryptOperation({
      name: "untitled.txt"
    });
    operation.encryptName();
    test.ok(operation.ciphertextBytes.length === 1);
    decryptor = miniLockLib.NACL.stream.createDecryptor(operation.fileKey, operation.fileNonce, operation.chunkSize);
    return test.end();
  });

  tape("construct a permit to decrypt for a recipient", function(test) {
    var operation, permit, uniqueNonce, _ref1;
    operation = new miniLockLib.EncryptOperation({
      keys: Alice.keys
    });
    _ref1 = operation.permit(Bobby.miniLockID), uniqueNonce = _ref1[0], permit = _ref1[1];
    test.ok(uniqueNonce.constructor === Uint8Array);
    test.ok(uniqueNonce.length === 24);
    test.ok(permit.senderID === Alice.miniLockID);
    test.ok(permit.recipientID === Bobby.miniLockID);
    test.ok(permit.fileInfo.constructor === String);
    test.ok(permit.fileInfo !== "");
    return test.end();
  });

  tape("recipient can decrypt the key, nonce and hash of the file encoded in their permit", function(test) {
    var decodedFileInfo, decryptedFileInfo, fileInfo, operation, permit, uniqueNonce, _ref1;
    operation = new miniLockLib.EncryptOperation({
      keys: Alice.keys
    });
    _ref1 = operation.permit(Bobby.miniLockID), uniqueNonce = _ref1[0], permit = _ref1[1];
    decodedFileInfo = miniLockLib.NACL.util.decodeBase64(permit.fileInfo);
    decryptedFileInfo = miniLockLib.NACL.box.open(decodedFileInfo, uniqueNonce, Alice.publicKey, Bobby.secretKey);
    test.ok(decryptedFileInfo);
    fileInfo = JSON.parse(miniLockLib.NACL.util.encodeUTF8(decryptedFileInfo));
    test.ok(fileInfo.fileKey != null);
    test.ok(fileInfo.fileNonce != null);
    test.ok(fileInfo.fileHash === "aSF6MHmQgJThESHQQjVKfB9VtkgsoaUeGyUN/R7Q7vk=");
    return test.end();
  });

  tape("header specifies version 1 of the miniLock file format", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation({
      keys: Alice.keys,
      miniLockIDs: [Alice.miniLockID]
    });
    operation.constructHeader();
    test.ok(operation.header.version === 1);
    return test.end();
  });

  tape("header has a Base64 encoded 32-byte ephemeral key", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation({
      keys: Alice.keys,
      miniLockIDs: [Alice.miniLockID]
    });
    operation.constructHeader();
    test.ok(miniLockLib.NACL.util.decodeBase64(operation.header.ephemeral).length === 32);
    return test.end();
  });

  tape("header for one recipient has one permit", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation({
      keys: Alice.keys,
      miniLockIDs: [Alice.miniLockID]
    });
    operation.constructHeader();
    test.ok(Object.keys(operation.header.decryptInfo).length === 1);
    return test.end();
  });

  tape("header for two recipients has two permits", function(test) {
    var operation;
    operation = new miniLockLib.EncryptOperation({
      keys: Alice.keys,
      miniLockIDs: [Alice.miniLockID, Bobby.miniLockID]
    });
    operation.constructHeader();
    test.ok(Object.keys(operation.header.decryptInfo).length === 2);
    return test.end();
  });

}).call(this);
